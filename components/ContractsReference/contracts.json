[
  {
    "kind": "user",
    "methods": {
      "VERSION()": {
        "notice": "Returns the version of the Safe contract."
      },
      "addOwnerWithThreshold(address,uint256)": {
        "notice": "Adds the owner `owner` to the Safe and updates the threshold to `_threshold`."
      },
      "approveHash(bytes32)": {
        "notice": "Marks hash `hashToApprove` as approved."
      },
      "approvedHashes(address,bytes32)": {
        "notice": "Returns a uint if the messageHash is approved by the owner."
      },
      "changeThreshold(uint256)": {
        "notice": "Changes the threshold of the Safe to `_threshold`."
      },
      "checkNSignatures(address,bytes32,bytes,uint256)": {
        "notice": "Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise."
      },
      "checkNSignatures(bytes32,bytes,bytes,uint256)": {
        "notice": "Checks whether the signature provided is valid for the provided hash. Reverts otherwise.         The `data` parameter is completely ignored during signature verification."
      },
      "checkSignatures(bytes32,bytes)": {
        "notice": "Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise."
      },
      "checkSignatures(bytes32,bytes,bytes)": {
        "notice": "Checks whether the signature provided is valid for the provided hash. Reverts otherwise.         The `data` parameter is completely ignored during signature verification."
      },
      "disableModule(address,address)": {
        "notice": "Disables the module `module` for the Safe."
      },
      "enableModule(address)": {
        "notice": "Enables the module `module` for the Safe."
      },
      "execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)": {
        "notice": "Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`."
      },
      "execTransactionFromModule(address,uint256,bytes,uint8)": {
        "notice": "Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)"
      },
      "execTransactionFromModuleReturnData(address,uint256,bytes,uint8)": {
        "notice": "Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data"
      },
      "getModulesPaginated(address,uint256)": {
        "notice": "Returns an array of modules.         If all entries fit into a single page, the next pointer will be 0x1.         If another page is present, next will be the last element of the returned array."
      },
      "getOwners()": {
        "notice": "Returns a list of Safe owners."
      },
      "getStorageAt(uint256,uint256)": {
        "notice": "Reads `length` bytes of storage in the currents contract"
      },
      "getThreshold()": {
        "notice": "Returns the number of required confirmations for a Safe transaction aka the threshold."
      },
      "getTransactionHash(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,uint256)": {
        "notice": "Returns transaction hash to be signed by owners."
      },
      "isModuleEnabled(address)": {
        "notice": "Returns if an module is enabled"
      },
      "isOwner(address)": {
        "notice": "Returns if `owner` is an owner of the Safe."
      },
      "nonce()": {
        "notice": "Returns the nonce of the Safe contract."
      },
      "removeOwner(address,address,uint256)": {
        "notice": "Removes the owner `owner` from the Safe and updates the threshold to `_threshold`."
      },
      "setFallbackHandler(address)": {
        "notice": "Set Fallback Handler to `handler` for the Safe."
      },
      "setGuard(address)": {
        "notice": "Set Transaction Guard `guard` for the Safe. Make sure you trust the guard."
      },
      "setModuleGuard(address)": {
        "notice": "Set Module Guard `moduleGuard` for the Safe. Make sure you trust the module guard."
      },
      "setup(address[],uint256,address,bytes,address,address,uint256,address)": {
        "notice": "Sets an initial storage of the Safe contract."
      },
      "signedMessages(bytes32)": {
        "notice": "Returns a uint if the messageHash is signed by the owner."
      },
      "swapOwner(address,address,address)": {
        "notice": "Replaces the owner `oldOwner` in the Safe with `newOwner`."
      }
    },
    "version": 1,
    "contract": "/Safe.sol"
  },
  {
    "kind": "user",
    "methods": {
      "VERSION()": {
        "notice": "Returns the version of the Safe contract."
      },
      "addOwnerWithThreshold(address,uint256)": {
        "notice": "Adds the owner `owner` to the Safe and updates the threshold to `_threshold`."
      },
      "approveHash(bytes32)": {
        "notice": "Marks hash `hashToApprove` as approved."
      },
      "approvedHashes(address,bytes32)": {
        "notice": "Returns a uint if the messageHash is approved by the owner."
      },
      "changeThreshold(uint256)": {
        "notice": "Changes the threshold of the Safe to `_threshold`."
      },
      "checkNSignatures(address,bytes32,bytes,uint256)": {
        "notice": "Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise."
      },
      "checkNSignatures(bytes32,bytes,bytes,uint256)": {
        "notice": "Checks whether the signature provided is valid for the provided hash. Reverts otherwise.         The `data` parameter is completely ignored during signature verification."
      },
      "checkSignatures(bytes32,bytes)": {
        "notice": "Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise."
      },
      "checkSignatures(bytes32,bytes,bytes)": {
        "notice": "Checks whether the signature provided is valid for the provided hash. Reverts otherwise.         The `data` parameter is completely ignored during signature verification."
      },
      "disableModule(address,address)": {
        "notice": "Disables the module `module` for the Safe."
      },
      "enableModule(address)": {
        "notice": "Enables the module `module` for the Safe."
      },
      "execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)": {
        "notice": "Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`."
      },
      "execTransactionFromModule(address,uint256,bytes,uint8)": {
        "notice": "Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)"
      },
      "execTransactionFromModuleReturnData(address,uint256,bytes,uint8)": {
        "notice": "Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data"
      },
      "getModulesPaginated(address,uint256)": {
        "notice": "Returns an array of modules.         If all entries fit into a single page, the next pointer will be 0x1.         If another page is present, next will be the last element of the returned array."
      },
      "getOwners()": {
        "notice": "Returns a list of Safe owners."
      },
      "getStorageAt(uint256,uint256)": {
        "notice": "Reads `length` bytes of storage in the currents contract"
      },
      "getThreshold()": {
        "notice": "Returns the number of required confirmations for a Safe transaction aka the threshold."
      },
      "getTransactionHash(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,uint256)": {
        "notice": "Returns transaction hash to be signed by owners."
      },
      "isModuleEnabled(address)": {
        "notice": "Returns if an module is enabled"
      },
      "isOwner(address)": {
        "notice": "Returns if `owner` is an owner of the Safe."
      },
      "nonce()": {
        "notice": "Returns the nonce of the Safe contract."
      },
      "removeOwner(address,address,uint256)": {
        "notice": "Removes the owner `owner` from the Safe and updates the threshold to `_threshold`."
      },
      "setFallbackHandler(address)": {
        "notice": "Set Fallback Handler to `handler` for the Safe."
      },
      "setGuard(address)": {
        "notice": "Set Transaction Guard `guard` for the Safe. Make sure you trust the guard."
      },
      "setModuleGuard(address)": {
        "notice": "Set Module Guard `moduleGuard` for the Safe. Make sure you trust the module guard."
      },
      "setup(address[],uint256,address,bytes,address,address,uint256,address)": {
        "notice": "Sets an initial storage of the Safe contract."
      },
      "signedMessages(bytes32)": {
        "notice": "Returns a uint if the messageHash is signed by the owner."
      },
      "swapOwner(address,address,address)": {
        "notice": "Replaces the owner `oldOwner` in the Safe with `newOwner`."
      }
    },
    "version": 1,
    "contract": "/SafeL2.sol"
  },
  {
    "kind": "user",
    "methods": {
      "simulate(address,uint256,bytes,uint8)": {
        "notice": "Simulates a Safe transaction and returns the used gas, success boolean and the return data."
      }
    },
    "notice": "Can be used with StorageAccessible to simulate Safe transactions.",
    "version": 1,
    "contract": "/accessors/SimulateTxAccessor.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/base/Executor.sol"
  },
  {
    "kind": "user",
    "methods": {
      "setFallbackHandler(address)": {
        "notice": "Set Fallback Handler to `handler` for the Safe."
      }
    },
    "version": 1,
    "contract": "/base/FallbackManager.sol"
  },
  {
    "kind": "user",
    "methods": {
      "checkAfterExecution(bytes32,bool)": {
        "notice": "Checks after execution of transaction."
      },
      "checkTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes,address)": {
        "notice": "Checks the transaction details."
      }
    },
    "version": 1,
    "contract": "/base/GuardManager.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/base/ModuleManager.sol"
  },
  {
    "kind": "user",
    "methods": {
      "addOwnerWithThreshold(address,uint256)": {
        "notice": "Adds the owner `owner` to the Safe and updates the threshold to `_threshold`."
      },
      "changeThreshold(uint256)": {
        "notice": "Changes the threshold of the Safe to `_threshold`."
      },
      "getOwners()": {
        "notice": "Returns a list of Safe owners."
      },
      "getThreshold()": {
        "notice": "Returns the number of required confirmations for a Safe transaction aka the threshold."
      },
      "isOwner(address)": {
        "notice": "Returns if `owner` is an owner of the Safe."
      },
      "removeOwner(address,address,uint256)": {
        "notice": "Removes the owner `owner` from the Safe and updates the threshold to `_threshold`."
      },
      "swapOwner(address,address,address)": {
        "notice": "Replaces the owner `oldOwner` in the Safe with `newOwner`."
      }
    },
    "version": 1,
    "contract": "/base/OwnerManager.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/common/NativeCurrencyPaymentFallback.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/common/SecuredTokenTransfer.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/common/SelfAuthorized.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/common/SignatureDecoder.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/common/Singleton.sol"
  },
  {
    "kind": "user",
    "methods": {
      "getStorageAt(uint256,uint256)": {
        "notice": "Reads `length` bytes of storage in the currents contract"
      }
    },
    "notice": "See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol         It removes a method from the original contract not needed for the Safe Smart Account contracts.",
    "version": 1,
    "contract": "/common/StorageAccessible.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/examples/guards/BaseGuard.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/examples/guards/DebugTransactionGuard.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/examples/guards/DelegateCallTransactionGuard.sol"
  },
  {
    "kind": "user",
    "methods": {
      "checkAfterExecution(bytes32,bool)": {
        "notice": "Checks after execution of transaction."
      },
      "checkTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes,address)": {
        "notice": "Checks the transaction details."
      }
    },
    "version": 1,
    "contract": "/examples/guards/OnlyOwnersGuard.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/examples/guards/ReentrancyTransactionGuard.sol"
  },
  {
    "kind": "user",
    "methods": {
      "migrate()": {
        "notice": "Migrates the Safe to the Singleton contract at `migrationSingleton`."
      }
    },
    "version": 1,
    "contract": "/examples/libraries/Migrate_1_3_0_to_1_2_0.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "notice": "Math operations with safety checks that revert on error (overflow/underflow)",
    "version": 1,
    "contract": "/external/SafeMath.sol"
  },
  {
    "kind": "user",
    "methods": {
      "isValidSignature(bytes32,bytes)": {
        "notice": "Implementation of updated EIP-1271 signature validation method."
      },
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
        "notice": "Handles ERC1155 Token batch callback. return Standardized onERC1155BatchReceived return value."
      },
      "onERC1155Received(address,address,uint256,uint256,bytes)": {
        "notice": "Handles ERC1155 Token callback. return Standardized onERC1155Received return value."
      },
      "onERC721Received(address,address,uint256,bytes)": {
        "notice": "Handles ERC721 Token callback.  return Standardized onERC721Received return value."
      },
      "supportsInterface(bytes4)": {
        "notice": "Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165."
      },
      "tokensReceived(address,address,address,uint256,bytes,bytes)": {
        "notice": "Handles ERC777 Token callback. return nothing (not standardized)"
      }
    },
    "version": 1,
    "contract": "/handler/CompatibilityFallbackHandler.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/handler/HandlerContext.sol"
  },
  {
    "kind": "user",
    "methods": {
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
        "notice": "Handles ERC1155 Token batch callback. return Standardized onERC1155BatchReceived return value."
      },
      "onERC1155Received(address,address,uint256,uint256,bytes)": {
        "notice": "Handles ERC1155 Token callback. return Standardized onERC1155Received return value."
      },
      "onERC721Received(address,address,uint256,bytes)": {
        "notice": "Handles ERC721 Token callback.  return Standardized onERC721Received return value."
      },
      "supportsInterface(bytes4)": {
        "notice": "Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165."
      },
      "tokensReceived(address,address,address,uint256,bytes,bytes)": {
        "notice": "Handles ERC777 Token callback. return nothing (not standardized)"
      }
    },
    "version": 1,
    "contract": "/handler/TokenCallbackHandler.sol"
  },
  {
    "kind": "user",
    "methods": {
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": {
        "notice": "Handle the receipt of multiple ERC1155 token types."
      },
      "onERC1155Received(address,address,uint256,uint256,bytes)": {
        "notice": "Handle the receipt of a single ERC1155 token type."
      }
    },
    "version": 1,
    "contract": "/interfaces/ERC1155TokenReceiver.sol"
  },
  {
    "kind": "user",
    "methods": {
      "onERC721Received(address,address,uint256,bytes)": {
        "notice": "Handle the receipt of an NFT"
      }
    },
    "version": 1,
    "contract": "/interfaces/ERC721TokenReceiver.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/interfaces/ERC777TokensRecipient.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "notice": "More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol",
    "version": 1,
    "contract": "/interfaces/IERC165.sol"
  },
  {
    "kind": "user",
    "methods": {
      "setFallbackHandler(address)": {
        "notice": "Set Fallback Handler to `handler` for the Safe."
      }
    },
    "version": 1,
    "contract": "/interfaces/IFallbackManager.sol"
  },
  {
    "kind": "user",
    "methods": {
      "setGuard(address)": {
        "notice": "Set Transaction Guard `guard` for the Safe. Make sure you trust the guard."
      }
    },
    "version": 1,
    "contract": "/interfaces/IGuardManager.sol"
  },
  {
    "kind": "user",
    "methods": {
      "disableModule(address,address)": {
        "notice": "Disables the module `module` for the Safe."
      },
      "enableModule(address)": {
        "notice": "Enables the module `module` for the Safe."
      },
      "execTransactionFromModule(address,uint256,bytes,uint8)": {
        "notice": "Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)"
      },
      "execTransactionFromModuleReturnData(address,uint256,bytes,uint8)": {
        "notice": "Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token) and return data"
      },
      "getModulesPaginated(address,uint256)": {
        "notice": "Returns an array of modules.         If all entries fit into a single page, the next pointer will be 0x1.         If another page is present, next will be the last element of the returned array."
      },
      "isModuleEnabled(address)": {
        "notice": "Returns if an module is enabled"
      },
      "setModuleGuard(address)": {
        "notice": "Set Module Guard `moduleGuard` for the Safe. Make sure you trust the module guard."
      }
    },
    "notice": "Modules are extensions with unlimited access to a Safe that can be added to a Safe by its owners. ⚠️ WARNING: Modules are a security risk since they can execute arbitrary transactions,  so only trusted and audited modules should be added to a Safe. A malicious module can completely takeover a Safe.",
    "version": 1,
    "contract": "/interfaces/IModuleManager.sol"
  },
  {
    "kind": "user",
    "methods": {
      "addOwnerWithThreshold(address,uint256)": {
        "notice": "Adds the owner `owner` to the Safe and updates the threshold to `_threshold`."
      },
      "changeThreshold(uint256)": {
        "notice": "Changes the threshold of the Safe to `_threshold`."
      },
      "getOwners()": {
        "notice": "Returns a list of Safe owners."
      },
      "getThreshold()": {
        "notice": "Returns the number of required confirmations for a Safe transaction aka the threshold."
      },
      "isOwner(address)": {
        "notice": "Returns if `owner` is an owner of the Safe."
      },
      "removeOwner(address,address,uint256)": {
        "notice": "Removes the owner `owner` from the Safe and updates the threshold to `_threshold`."
      },
      "swapOwner(address,address,address)": {
        "notice": "Replaces the owner `oldOwner` in the Safe with `newOwner`."
      }
    },
    "version": 1,
    "contract": "/interfaces/IOwnerManager.sol"
  },
  {
    "kind": "user",
    "methods": {
      "setFallbackHandler(address)": {
        "notice": "Set Fallback Handler to `handler` for the Safe."
      }
    },
    "version": 1,
    "contract": "/interfaces/ISafe.sol"
  },
  {
    "kind": "user",
    "methods": {
      "isValidSignature(bytes32,bytes)": {
        "notice": "EIP1271 method to validate a signature."
      }
    },
    "version": 1,
    "contract": "/interfaces/ISignatureValidator.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "notice": "Adjusted version of https://github.com/gnosis/util-contracts/blob/3db1e531cb243a48ea91c60a800d537c1000612a/contracts/StorageAccessible.sol",
    "version": 1,
    "contract": "/interfaces/ViewStorageAccessible.sol"
  },
  {
    "events": {
      "ContractCreation(address)": {
        "notice": "Emitted when a new contract is created"
      }
    },
    "kind": "user",
    "methods": {
      "performCreate(uint256,bytes)": {
        "notice": "Deploys a new contract using the create opcode."
      },
      "performCreate2(uint256,bytes,bytes32)": {
        "notice": "Deploys a new contract using the create2 opcode."
      }
    },
    "notice": "This contract provides functions for deploying a new contract using the create and create2 opcodes.",
    "version": 1,
    "contract": "/libraries/CreateCall.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/libraries/Enum.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "notice": "The aim is to save gas using assembly to revert with custom error message.",
    "version": 1,
    "contract": "/libraries/ErrorMessage.sol"
  },
  {
    "kind": "user",
    "methods": {
      "multiSend(bytes)": {
        "notice": "This method is payable as delegatecalls keep the msg.value from the previous call         If the calling method (e.g. execTransaction) received ETH this would revert otherwise"
      }
    },
    "version": 1,
    "contract": "/libraries/MultiSend.sol"
  },
  {
    "kind": "user",
    "methods": {
      "multiSend(bytes)": {
        "notice": "The code is for most part the same as the normal MultiSend (to keep compatibility),         but reverts if a transaction tries to use a delegatecall.This method is payable as delegatecalls keep the msg.value from the previous call         If the calling method (e.g. execTransaction) received ETH this would revert otherwise"
      }
    },
    "notice": "The guard logic is not required here as this contract doesn't support nested delegate calls",
    "version": 1,
    "contract": "/libraries/MultiSendCallOnly.sol"
  },
  {
    "kind": "user",
    "methods": {
      "setFallbackHandler(address)": {
        "notice": "Set Fallback Handler to `handler` for the Safe."
      }
    },
    "version": 1,
    "contract": "/libraries/SafeMigration.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/libraries/SafeStorage.sol"
  },
  {
    "kind": "user",
    "methods": {
      "setFallbackHandler(address)": {
        "notice": "Set Fallback Handler to `handler` for the Safe."
      }
    },
    "version": 1,
    "contract": "/libraries/SafeToL2Migration.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/libraries/SafeToL2Setup.sol"
  },
  {
    "kind": "user",
    "methods": {
      "setFallbackHandler(address)": {
        "notice": "Set Fallback Handler to `handler` for the Safe."
      }
    },
    "version": 1,
    "contract": "/libraries/SignMessageLib.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/proxies/IProxyCreationCallback.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/proxies/SafeProxy.sol"
  },
  {
    "kind": "user",
    "methods": {},
    "version": 1,
    "contract": "/proxies/SafeProxyFactory.sol"
  }
]